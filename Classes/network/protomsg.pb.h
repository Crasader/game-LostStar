// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protomsg.proto

#ifndef PROTOBUF_protomsg_2eproto__INCLUDED
#define PROTOBUF_protomsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace Star {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protomsg_2eproto();
void protobuf_AssignDesc_protomsg_2eproto();
void protobuf_ShutdownFile_protomsg_2eproto();

class AccountInfo;
class TaskInfo;
class SolutionInfo;
class SyncReq;
class SyncRsp;
class UploadTaskInfoReq;
class UploadTaskInfoRsp;
class UploadSolutionReq;
class UploadSolutionRsp;
class DownloadSolutionReq;
class DownloadSolutionRsp;
class UpSolutionReq;
class UpSolutionRsp;
class FriendsInfo;
class QueryFriendsInfoReq;
class QueryFriendsInfoRsp;

enum PlatformType {
  PlatformType_Invalid = 0,
  PlatformType_Common = 1,
  PlatformType_Facebook = 2
};
bool PlatformType_IsValid(int value);
const PlatformType PlatformType_MIN = PlatformType_Invalid;
const PlatformType PlatformType_MAX = PlatformType_Facebook;
const int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

// ===================================================================

class AccountInfo : public ::google::protobuf::MessageLite {
 public:
  AccountInfo();
  virtual ~AccountInfo();

  AccountInfo(const AccountInfo& from);

  inline AccountInfo& operator=(const AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AccountInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AccountInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AccountInfo* other);

  // implements Message ----------------------------------------------

  AccountInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AccountInfo& from);
  void MergeFrom(const AccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Star.PlatformType platform = 1;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 1;
  inline ::Star::PlatformType platform() const;
  inline void set_platform(::Star::PlatformType value);

  // required string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:Star.AccountInfo)
 private:
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_account();
  inline void clear_has_account();

  ::std::string* account_;
  int platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static AccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::MessageLite {
 public:
  TaskInfo();
  virtual ~TaskInfo();

  TaskInfo(const TaskInfo& from);

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TaskInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TaskInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TaskInfo* other);

  // implements Message ----------------------------------------------

  TaskInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::int64 task_id() const;
  inline void set_task_id(::google::protobuf::int64 value);

  // optional int32 star = 2;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 2;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 highest_score = 4;
  inline bool has_highest_score() const;
  inline void clear_highest_score();
  static const int kHighestScoreFieldNumber = 4;
  inline ::google::protobuf::int32 highest_score() const;
  inline void set_highest_score(::google::protobuf::int32 value);

  // optional int32 average_score = 5;
  inline bool has_average_score() const;
  inline void clear_average_score();
  static const int kAverageScoreFieldNumber = 5;
  inline ::google::protobuf::int32 average_score() const;
  inline void set_average_score(::google::protobuf::int32 value);

  // optional int32 player_count = 6;
  inline bool has_player_count() const;
  inline void clear_player_count();
  static const int kPlayerCountFieldNumber = 6;
  inline ::google::protobuf::int32 player_count() const;
  inline void set_player_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Star.TaskInfo)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_highest_score();
  inline void clear_has_highest_score();
  inline void set_has_average_score();
  inline void clear_has_average_score();
  inline void set_has_player_count();
  inline void clear_has_player_count();

  ::google::protobuf::int64 task_id_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 highest_score_;
  ::google::protobuf::int32 average_score_;
  ::google::protobuf::int32 player_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static TaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class SolutionInfo : public ::google::protobuf::MessageLite {
 public:
  SolutionInfo();
  virtual ~SolutionInfo();

  SolutionInfo(const SolutionInfo& from);

  inline SolutionInfo& operator=(const SolutionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SolutionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SolutionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SolutionInfo* other);

  // implements Message ----------------------------------------------

  SolutionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SolutionInfo& from);
  void MergeFrom(const SolutionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::int64 task_id() const;
  inline void set_task_id(::google::protobuf::int64 value);

  // optional int32 star = 2;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 2;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional string solution_id = 4;
  inline bool has_solution_id() const;
  inline void clear_solution_id();
  static const int kSolutionIdFieldNumber = 4;
  inline const ::std::string& solution_id() const;
  inline void set_solution_id(const ::std::string& value);
  inline void set_solution_id(const char* value);
  inline void set_solution_id(const char* value, size_t size);
  inline ::std::string* mutable_solution_id();
  inline ::std::string* release_solution_id();
  inline void set_allocated_solution_id(::std::string* solution_id);

  // optional int32 tag = 5;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 5;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional int32 download_times = 6;
  inline bool has_download_times() const;
  inline void clear_download_times();
  static const int kDownloadTimesFieldNumber = 6;
  inline ::google::protobuf::int32 download_times() const;
  inline void set_download_times(::google::protobuf::int32 value);

  // optional int32 up_times = 7;
  inline bool has_up_times() const;
  inline void clear_up_times();
  static const int kUpTimesFieldNumber = 7;
  inline ::google::protobuf::int32 up_times() const;
  inline void set_up_times(::google::protobuf::int32 value);

  // optional bytes data = 8;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 8;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Star.SolutionInfo)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_solution_id();
  inline void clear_has_solution_id();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_download_times();
  inline void clear_has_download_times();
  inline void set_has_up_times();
  inline void clear_has_up_times();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::int64 task_id_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::int32 score_;
  ::std::string* solution_id_;
  ::google::protobuf::int32 tag_;
  ::google::protobuf::int32 download_times_;
  ::std::string* data_;
  ::google::protobuf::int32 up_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static SolutionInfo* default_instance_;
};
// -------------------------------------------------------------------

class SyncReq : public ::google::protobuf::MessageLite {
 public:
  SyncReq();
  virtual ~SyncReq();

  SyncReq(const SyncReq& from);

  inline SyncReq& operator=(const SyncReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const SyncReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncReq* other);

  // implements Message ----------------------------------------------

  SyncReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncReq& from);
  void MergeFrom(const SyncReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Star.AccountInfo acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::Star::AccountInfo& acc() const;
  inline ::Star::AccountInfo* mutable_acc();
  inline ::Star::AccountInfo* release_acc();
  inline void set_allocated_acc(::Star::AccountInfo* acc);

  // repeated .Star.TaskInfo task = 2;
  inline int task_size() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 2;
  inline const ::Star::TaskInfo& task(int index) const;
  inline ::Star::TaskInfo* mutable_task(int index);
  inline ::Star::TaskInfo* add_task();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
      task() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
      mutable_task();

  // @@protoc_insertion_point(class_scope:Star.SyncReq)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();

  ::Star::AccountInfo* acc_;
  ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo > task_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static SyncReq* default_instance_;
};
// -------------------------------------------------------------------

class SyncRsp : public ::google::protobuf::MessageLite {
 public:
  SyncRsp();
  virtual ~SyncRsp();

  SyncRsp(const SyncRsp& from);

  inline SyncRsp& operator=(const SyncRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const SyncRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncRsp* other);

  // implements Message ----------------------------------------------

  SyncRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncRsp& from);
  void MergeFrom(const SyncRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .Star.TaskInfo need_up_task = 2;
  inline int need_up_task_size() const;
  inline void clear_need_up_task();
  static const int kNeedUpTaskFieldNumber = 2;
  inline const ::Star::TaskInfo& need_up_task(int index) const;
  inline ::Star::TaskInfo* mutable_need_up_task(int index);
  inline ::Star::TaskInfo* add_need_up_task();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
      need_up_task() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
      mutable_need_up_task();

  // repeated .Star.SolutionInfo down_task = 3;
  inline int down_task_size() const;
  inline void clear_down_task();
  static const int kDownTaskFieldNumber = 3;
  inline const ::Star::SolutionInfo& down_task(int index) const;
  inline ::Star::SolutionInfo* mutable_down_task(int index);
  inline ::Star::SolutionInfo* add_down_task();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >&
      down_task() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >*
      mutable_down_task();

  // @@protoc_insertion_point(class_scope:Star.SyncRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo > need_up_task_;
  ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo > down_task_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static SyncRsp* default_instance_;
};
// -------------------------------------------------------------------

class UploadTaskInfoReq : public ::google::protobuf::MessageLite {
 public:
  UploadTaskInfoReq();
  virtual ~UploadTaskInfoReq();

  UploadTaskInfoReq(const UploadTaskInfoReq& from);

  inline UploadTaskInfoReq& operator=(const UploadTaskInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UploadTaskInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UploadTaskInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UploadTaskInfoReq* other);

  // implements Message ----------------------------------------------

  UploadTaskInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UploadTaskInfoReq& from);
  void MergeFrom(const UploadTaskInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Star.AccountInfo acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::Star::AccountInfo& acc() const;
  inline ::Star::AccountInfo* mutable_acc();
  inline ::Star::AccountInfo* release_acc();
  inline void set_allocated_acc(::Star::AccountInfo* acc);

  // repeated .Star.TaskInfo task = 2;
  inline int task_size() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 2;
  inline const ::Star::TaskInfo& task(int index) const;
  inline ::Star::TaskInfo* mutable_task(int index);
  inline ::Star::TaskInfo* add_task();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
      task() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
      mutable_task();

  // @@protoc_insertion_point(class_scope:Star.UploadTaskInfoReq)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();

  ::Star::AccountInfo* acc_;
  ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo > task_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static UploadTaskInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class UploadTaskInfoRsp : public ::google::protobuf::MessageLite {
 public:
  UploadTaskInfoRsp();
  virtual ~UploadTaskInfoRsp();

  UploadTaskInfoRsp(const UploadTaskInfoRsp& from);

  inline UploadTaskInfoRsp& operator=(const UploadTaskInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UploadTaskInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UploadTaskInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UploadTaskInfoRsp* other);

  // implements Message ----------------------------------------------

  UploadTaskInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UploadTaskInfoRsp& from);
  void MergeFrom(const UploadTaskInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Star.UploadTaskInfoRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static UploadTaskInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class UploadSolutionReq : public ::google::protobuf::MessageLite {
 public:
  UploadSolutionReq();
  virtual ~UploadSolutionReq();

  UploadSolutionReq(const UploadSolutionReq& from);

  inline UploadSolutionReq& operator=(const UploadSolutionReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UploadSolutionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UploadSolutionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UploadSolutionReq* other);

  // implements Message ----------------------------------------------

  UploadSolutionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UploadSolutionReq& from);
  void MergeFrom(const UploadSolutionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Star.AccountInfo acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::Star::AccountInfo& acc() const;
  inline ::Star::AccountInfo* mutable_acc();
  inline ::Star::AccountInfo* release_acc();
  inline void set_allocated_acc(::Star::AccountInfo* acc);

  // repeated .Star.SolutionInfo solution = 2;
  inline int solution_size() const;
  inline void clear_solution();
  static const int kSolutionFieldNumber = 2;
  inline const ::Star::SolutionInfo& solution(int index) const;
  inline ::Star::SolutionInfo* mutable_solution(int index);
  inline ::Star::SolutionInfo* add_solution();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >&
      solution() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >*
      mutable_solution();

  // @@protoc_insertion_point(class_scope:Star.UploadSolutionReq)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();

  ::Star::AccountInfo* acc_;
  ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo > solution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static UploadSolutionReq* default_instance_;
};
// -------------------------------------------------------------------

class UploadSolutionRsp : public ::google::protobuf::MessageLite {
 public:
  UploadSolutionRsp();
  virtual ~UploadSolutionRsp();

  UploadSolutionRsp(const UploadSolutionRsp& from);

  inline UploadSolutionRsp& operator=(const UploadSolutionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UploadSolutionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UploadSolutionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UploadSolutionRsp* other);

  // implements Message ----------------------------------------------

  UploadSolutionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UploadSolutionRsp& from);
  void MergeFrom(const UploadSolutionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Star.UploadSolutionRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static UploadSolutionRsp* default_instance_;
};
// -------------------------------------------------------------------

class DownloadSolutionReq : public ::google::protobuf::MessageLite {
 public:
  DownloadSolutionReq();
  virtual ~DownloadSolutionReq();

  DownloadSolutionReq(const DownloadSolutionReq& from);

  inline DownloadSolutionReq& operator=(const DownloadSolutionReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const DownloadSolutionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DownloadSolutionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DownloadSolutionReq* other);

  // implements Message ----------------------------------------------

  DownloadSolutionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DownloadSolutionReq& from);
  void MergeFrom(const DownloadSolutionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Star.AccountInfo acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::Star::AccountInfo& acc() const;
  inline ::Star::AccountInfo* mutable_acc();
  inline ::Star::AccountInfo* release_acc();
  inline void set_allocated_acc(::Star::AccountInfo* acc);

  // optional string solution_id = 2;
  inline bool has_solution_id() const;
  inline void clear_solution_id();
  static const int kSolutionIdFieldNumber = 2;
  inline const ::std::string& solution_id() const;
  inline void set_solution_id(const ::std::string& value);
  inline void set_solution_id(const char* value);
  inline void set_solution_id(const char* value, size_t size);
  inline ::std::string* mutable_solution_id();
  inline ::std::string* release_solution_id();
  inline void set_allocated_solution_id(::std::string* solution_id);

  // @@protoc_insertion_point(class_scope:Star.DownloadSolutionReq)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_solution_id();
  inline void clear_has_solution_id();

  ::Star::AccountInfo* acc_;
  ::std::string* solution_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static DownloadSolutionReq* default_instance_;
};
// -------------------------------------------------------------------

class DownloadSolutionRsp : public ::google::protobuf::MessageLite {
 public:
  DownloadSolutionRsp();
  virtual ~DownloadSolutionRsp();

  DownloadSolutionRsp(const DownloadSolutionRsp& from);

  inline DownloadSolutionRsp& operator=(const DownloadSolutionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const DownloadSolutionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DownloadSolutionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DownloadSolutionRsp* other);

  // implements Message ----------------------------------------------

  DownloadSolutionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DownloadSolutionRsp& from);
  void MergeFrom(const DownloadSolutionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // optional .Star.SolutionInfo soulution = 2;
  inline bool has_soulution() const;
  inline void clear_soulution();
  static const int kSoulutionFieldNumber = 2;
  inline const ::Star::SolutionInfo& soulution() const;
  inline ::Star::SolutionInfo* mutable_soulution();
  inline ::Star::SolutionInfo* release_soulution();
  inline void set_allocated_soulution(::Star::SolutionInfo* soulution);

  // @@protoc_insertion_point(class_scope:Star.DownloadSolutionRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_soulution();
  inline void clear_has_soulution();

  ::Star::SolutionInfo* soulution_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static DownloadSolutionRsp* default_instance_;
};
// -------------------------------------------------------------------

class UpSolutionReq : public ::google::protobuf::MessageLite {
 public:
  UpSolutionReq();
  virtual ~UpSolutionReq();

  UpSolutionReq(const UpSolutionReq& from);

  inline UpSolutionReq& operator=(const UpSolutionReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpSolutionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpSolutionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpSolutionReq* other);

  // implements Message ----------------------------------------------

  UpSolutionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpSolutionReq& from);
  void MergeFrom(const UpSolutionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Star.AccountInfo acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::Star::AccountInfo& acc() const;
  inline ::Star::AccountInfo* mutable_acc();
  inline ::Star::AccountInfo* release_acc();
  inline void set_allocated_acc(::Star::AccountInfo* acc);

  // optional string solution_id = 2;
  inline bool has_solution_id() const;
  inline void clear_solution_id();
  static const int kSolutionIdFieldNumber = 2;
  inline const ::std::string& solution_id() const;
  inline void set_solution_id(const ::std::string& value);
  inline void set_solution_id(const char* value);
  inline void set_solution_id(const char* value, size_t size);
  inline ::std::string* mutable_solution_id();
  inline ::std::string* release_solution_id();
  inline void set_allocated_solution_id(::std::string* solution_id);

  // optional bool is_up = 3;
  inline bool has_is_up() const;
  inline void clear_is_up();
  static const int kIsUpFieldNumber = 3;
  inline bool is_up() const;
  inline void set_is_up(bool value);

  // @@protoc_insertion_point(class_scope:Star.UpSolutionReq)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_solution_id();
  inline void clear_has_solution_id();
  inline void set_has_is_up();
  inline void clear_has_is_up();

  ::Star::AccountInfo* acc_;
  ::std::string* solution_id_;
  bool is_up_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static UpSolutionReq* default_instance_;
};
// -------------------------------------------------------------------

class UpSolutionRsp : public ::google::protobuf::MessageLite {
 public:
  UpSolutionRsp();
  virtual ~UpSolutionRsp();

  UpSolutionRsp(const UpSolutionRsp& from);

  inline UpSolutionRsp& operator=(const UpSolutionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpSolutionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpSolutionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpSolutionRsp* other);

  // implements Message ----------------------------------------------

  UpSolutionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpSolutionRsp& from);
  void MergeFrom(const UpSolutionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // optional .Star.SolutionInfo soulution = 2;
  inline bool has_soulution() const;
  inline void clear_soulution();
  static const int kSoulutionFieldNumber = 2;
  inline const ::Star::SolutionInfo& soulution() const;
  inline ::Star::SolutionInfo* mutable_soulution();
  inline ::Star::SolutionInfo* release_soulution();
  inline void set_allocated_soulution(::Star::SolutionInfo* soulution);

  // @@protoc_insertion_point(class_scope:Star.UpSolutionRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_soulution();
  inline void clear_has_soulution();

  ::Star::SolutionInfo* soulution_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static UpSolutionRsp* default_instance_;
};
// -------------------------------------------------------------------

class FriendsInfo : public ::google::protobuf::MessageLite {
 public:
  FriendsInfo();
  virtual ~FriendsInfo();

  FriendsInfo(const FriendsInfo& from);

  inline FriendsInfo& operator=(const FriendsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendsInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendsInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendsInfo* other);

  // implements Message ----------------------------------------------

  FriendsInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendsInfo& from);
  void MergeFrom(const FriendsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // repeated .Star.SolutionInfo solution = 2;
  inline int solution_size() const;
  inline void clear_solution();
  static const int kSolutionFieldNumber = 2;
  inline const ::Star::SolutionInfo& solution(int index) const;
  inline ::Star::SolutionInfo* mutable_solution(int index);
  inline ::Star::SolutionInfo* add_solution();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >&
      solution() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >*
      mutable_solution();

  // @@protoc_insertion_point(class_scope:Star.FriendsInfo)
 private:
  inline void set_has_account();
  inline void clear_has_account();

  ::std::string* account_;
  ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo > solution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static FriendsInfo* default_instance_;
};
// -------------------------------------------------------------------

class QueryFriendsInfoReq : public ::google::protobuf::MessageLite {
 public:
  QueryFriendsInfoReq();
  virtual ~QueryFriendsInfoReq();

  QueryFriendsInfoReq(const QueryFriendsInfoReq& from);

  inline QueryFriendsInfoReq& operator=(const QueryFriendsInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryFriendsInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryFriendsInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryFriendsInfoReq* other);

  // implements Message ----------------------------------------------

  QueryFriendsInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryFriendsInfoReq& from);
  void MergeFrom(const QueryFriendsInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Star.PlatformType platform = 1;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 1;
  inline ::Star::PlatformType platform() const;
  inline void set_platform(::Star::PlatformType value);

  // repeated string account_list = 2;
  inline int account_list_size() const;
  inline void clear_account_list();
  static const int kAccountListFieldNumber = 2;
  inline const ::std::string& account_list(int index) const;
  inline ::std::string* mutable_account_list(int index);
  inline void set_account_list(int index, const ::std::string& value);
  inline void set_account_list(int index, const char* value);
  inline void set_account_list(int index, const char* value, size_t size);
  inline ::std::string* add_account_list();
  inline void add_account_list(const ::std::string& value);
  inline void add_account_list(const char* value);
  inline void add_account_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& account_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_account_list();

  // repeated int64 task_list = 3;
  inline int task_list_size() const;
  inline void clear_task_list();
  static const int kTaskListFieldNumber = 3;
  inline ::google::protobuf::int64 task_list(int index) const;
  inline void set_task_list(int index, ::google::protobuf::int64 value);
  inline void add_task_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      task_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_task_list();

  // @@protoc_insertion_point(class_scope:Star.QueryFriendsInfoReq)
 private:
  inline void set_has_platform();
  inline void clear_has_platform();

  ::google::protobuf::RepeatedPtrField< ::std::string> account_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > task_list_;
  int platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static QueryFriendsInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryFriendsInfoRsp : public ::google::protobuf::MessageLite {
 public:
  QueryFriendsInfoRsp();
  virtual ~QueryFriendsInfoRsp();

  QueryFriendsInfoRsp(const QueryFriendsInfoRsp& from);

  inline QueryFriendsInfoRsp& operator=(const QueryFriendsInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryFriendsInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryFriendsInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryFriendsInfoRsp* other);

  // implements Message ----------------------------------------------

  QueryFriendsInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryFriendsInfoRsp& from);
  void MergeFrom(const QueryFriendsInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .Star.TaskInfo task = 2;
  inline int task_size() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 2;
  inline const ::Star::TaskInfo& task(int index) const;
  inline ::Star::TaskInfo* mutable_task(int index);
  inline ::Star::TaskInfo* add_task();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
      task() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
      mutable_task();

  // repeated .Star.FriendsInfo friend = 3;
  inline int friend__size() const;
  inline void clear_friend_();
  static const int kFriendFieldNumber = 3;
  inline const ::Star::FriendsInfo& friend_(int index) const;
  inline ::Star::FriendsInfo* mutable_friend_(int index);
  inline ::Star::FriendsInfo* add_friend_();
  inline const ::google::protobuf::RepeatedPtrField< ::Star::FriendsInfo >&
      friend_() const;
  inline ::google::protobuf::RepeatedPtrField< ::Star::FriendsInfo >*
      mutable_friend_();

  // @@protoc_insertion_point(class_scope:Star.QueryFriendsInfoRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo > task_;
  ::google::protobuf::RepeatedPtrField< ::Star::FriendsInfo > friend__;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protomsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protomsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_protomsg_2eproto();
  friend void protobuf_ShutdownFile_protomsg_2eproto();

  void InitAsDefaultInstance();
  static QueryFriendsInfoRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// AccountInfo

// required .Star.PlatformType platform = 1;
inline bool AccountInfo::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountInfo::set_has_platform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountInfo::clear_has_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountInfo::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::Star::PlatformType AccountInfo::platform() const {
  return static_cast< ::Star::PlatformType >(platform_);
}
inline void AccountInfo::set_platform(::Star::PlatformType value) {
  assert(::Star::PlatformType_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// required string account = 2;
inline bool AccountInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& AccountInfo::account() const {
  return *account_;
}
inline void AccountInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* AccountInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TaskInfo

// required int64 task_id = 1;
inline bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
  clear_has_task_id();
}
inline ::google::protobuf::int64 TaskInfo::task_id() const {
  return task_id_;
}
inline void TaskInfo::set_task_id(::google::protobuf::int64 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional int32 star = 2;
inline bool TaskInfo::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 TaskInfo::star() const {
  return star_;
}
inline void TaskInfo::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// optional int32 score = 3;
inline bool TaskInfo::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskInfo::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 TaskInfo::score() const {
  return score_;
}
inline void TaskInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 highest_score = 4;
inline bool TaskInfo::has_highest_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskInfo::set_has_highest_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskInfo::clear_has_highest_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskInfo::clear_highest_score() {
  highest_score_ = 0;
  clear_has_highest_score();
}
inline ::google::protobuf::int32 TaskInfo::highest_score() const {
  return highest_score_;
}
inline void TaskInfo::set_highest_score(::google::protobuf::int32 value) {
  set_has_highest_score();
  highest_score_ = value;
}

// optional int32 average_score = 5;
inline bool TaskInfo::has_average_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskInfo::set_has_average_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskInfo::clear_has_average_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskInfo::clear_average_score() {
  average_score_ = 0;
  clear_has_average_score();
}
inline ::google::protobuf::int32 TaskInfo::average_score() const {
  return average_score_;
}
inline void TaskInfo::set_average_score(::google::protobuf::int32 value) {
  set_has_average_score();
  average_score_ = value;
}

// optional int32 player_count = 6;
inline bool TaskInfo::has_player_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskInfo::set_has_player_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskInfo::clear_has_player_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskInfo::clear_player_count() {
  player_count_ = 0;
  clear_has_player_count();
}
inline ::google::protobuf::int32 TaskInfo::player_count() const {
  return player_count_;
}
inline void TaskInfo::set_player_count(::google::protobuf::int32 value) {
  set_has_player_count();
  player_count_ = value;
}

// -------------------------------------------------------------------

// SolutionInfo

// required int64 task_id = 1;
inline bool SolutionInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolutionInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolutionInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolutionInfo::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
  clear_has_task_id();
}
inline ::google::protobuf::int64 SolutionInfo::task_id() const {
  return task_id_;
}
inline void SolutionInfo::set_task_id(::google::protobuf::int64 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional int32 star = 2;
inline bool SolutionInfo::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolutionInfo::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolutionInfo::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolutionInfo::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 SolutionInfo::star() const {
  return star_;
}
inline void SolutionInfo::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// optional int32 score = 3;
inline bool SolutionInfo::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolutionInfo::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolutionInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolutionInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 SolutionInfo::score() const {
  return score_;
}
inline void SolutionInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional string solution_id = 4;
inline bool SolutionInfo::has_solution_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolutionInfo::set_has_solution_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolutionInfo::clear_has_solution_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolutionInfo::clear_solution_id() {
  if (solution_id_ != &::google::protobuf::internal::kEmptyString) {
    solution_id_->clear();
  }
  clear_has_solution_id();
}
inline const ::std::string& SolutionInfo::solution_id() const {
  return *solution_id_;
}
inline void SolutionInfo::set_solution_id(const ::std::string& value) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(value);
}
inline void SolutionInfo::set_solution_id(const char* value) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(value);
}
inline void SolutionInfo::set_solution_id(const char* value, size_t size) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolutionInfo::mutable_solution_id() {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  return solution_id_;
}
inline ::std::string* SolutionInfo::release_solution_id() {
  clear_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = solution_id_;
    solution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolutionInfo::set_allocated_solution_id(::std::string* solution_id) {
  if (solution_id_ != &::google::protobuf::internal::kEmptyString) {
    delete solution_id_;
  }
  if (solution_id) {
    set_has_solution_id();
    solution_id_ = solution_id;
  } else {
    clear_has_solution_id();
    solution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 tag = 5;
inline bool SolutionInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolutionInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolutionInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolutionInfo::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 SolutionInfo::tag() const {
  return tag_;
}
inline void SolutionInfo::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional int32 download_times = 6;
inline bool SolutionInfo::has_download_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolutionInfo::set_has_download_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolutionInfo::clear_has_download_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolutionInfo::clear_download_times() {
  download_times_ = 0;
  clear_has_download_times();
}
inline ::google::protobuf::int32 SolutionInfo::download_times() const {
  return download_times_;
}
inline void SolutionInfo::set_download_times(::google::protobuf::int32 value) {
  set_has_download_times();
  download_times_ = value;
}

// optional int32 up_times = 7;
inline bool SolutionInfo::has_up_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolutionInfo::set_has_up_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolutionInfo::clear_has_up_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolutionInfo::clear_up_times() {
  up_times_ = 0;
  clear_has_up_times();
}
inline ::google::protobuf::int32 SolutionInfo::up_times() const {
  return up_times_;
}
inline void SolutionInfo::set_up_times(::google::protobuf::int32 value) {
  set_has_up_times();
  up_times_ = value;
}

// optional bytes data = 8;
inline bool SolutionInfo::has_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolutionInfo::set_has_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolutionInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolutionInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& SolutionInfo::data() const {
  return *data_;
}
inline void SolutionInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void SolutionInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void SolutionInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolutionInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* SolutionInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolutionInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SyncReq

// required .Star.AccountInfo acc = 1;
inline bool SyncReq::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncReq::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncReq::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncReq::clear_acc() {
  if (acc_ != NULL) acc_->::Star::AccountInfo::Clear();
  clear_has_acc();
}
inline const ::Star::AccountInfo& SyncReq::acc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return acc_ != NULL ? *acc_ : *default_instance().acc_;
#else
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
#endif
}
inline ::Star::AccountInfo* SyncReq::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::Star::AccountInfo;
  return acc_;
}
inline ::Star::AccountInfo* SyncReq::release_acc() {
  clear_has_acc();
  ::Star::AccountInfo* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline void SyncReq::set_allocated_acc(::Star::AccountInfo* acc) {
  delete acc_;
  acc_ = acc;
  if (acc) {
    set_has_acc();
  } else {
    clear_has_acc();
  }
}

// repeated .Star.TaskInfo task = 2;
inline int SyncReq::task_size() const {
  return task_.size();
}
inline void SyncReq::clear_task() {
  task_.Clear();
}
inline const ::Star::TaskInfo& SyncReq::task(int index) const {
  return task_.Get(index);
}
inline ::Star::TaskInfo* SyncReq::mutable_task(int index) {
  return task_.Mutable(index);
}
inline ::Star::TaskInfo* SyncReq::add_task() {
  return task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
SyncReq::task() const {
  return task_;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
SyncReq::mutable_task() {
  return &task_;
}

// -------------------------------------------------------------------

// SyncRsp

// required int32 rsp_code = 1;
inline bool SyncRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 SyncRsp::rsp_code() const {
  return rsp_code_;
}
inline void SyncRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .Star.TaskInfo need_up_task = 2;
inline int SyncRsp::need_up_task_size() const {
  return need_up_task_.size();
}
inline void SyncRsp::clear_need_up_task() {
  need_up_task_.Clear();
}
inline const ::Star::TaskInfo& SyncRsp::need_up_task(int index) const {
  return need_up_task_.Get(index);
}
inline ::Star::TaskInfo* SyncRsp::mutable_need_up_task(int index) {
  return need_up_task_.Mutable(index);
}
inline ::Star::TaskInfo* SyncRsp::add_need_up_task() {
  return need_up_task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
SyncRsp::need_up_task() const {
  return need_up_task_;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
SyncRsp::mutable_need_up_task() {
  return &need_up_task_;
}

// repeated .Star.SolutionInfo down_task = 3;
inline int SyncRsp::down_task_size() const {
  return down_task_.size();
}
inline void SyncRsp::clear_down_task() {
  down_task_.Clear();
}
inline const ::Star::SolutionInfo& SyncRsp::down_task(int index) const {
  return down_task_.Get(index);
}
inline ::Star::SolutionInfo* SyncRsp::mutable_down_task(int index) {
  return down_task_.Mutable(index);
}
inline ::Star::SolutionInfo* SyncRsp::add_down_task() {
  return down_task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >&
SyncRsp::down_task() const {
  return down_task_;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >*
SyncRsp::mutable_down_task() {
  return &down_task_;
}

// -------------------------------------------------------------------

// UploadTaskInfoReq

// required .Star.AccountInfo acc = 1;
inline bool UploadTaskInfoReq::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadTaskInfoReq::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadTaskInfoReq::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadTaskInfoReq::clear_acc() {
  if (acc_ != NULL) acc_->::Star::AccountInfo::Clear();
  clear_has_acc();
}
inline const ::Star::AccountInfo& UploadTaskInfoReq::acc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return acc_ != NULL ? *acc_ : *default_instance().acc_;
#else
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
#endif
}
inline ::Star::AccountInfo* UploadTaskInfoReq::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::Star::AccountInfo;
  return acc_;
}
inline ::Star::AccountInfo* UploadTaskInfoReq::release_acc() {
  clear_has_acc();
  ::Star::AccountInfo* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline void UploadTaskInfoReq::set_allocated_acc(::Star::AccountInfo* acc) {
  delete acc_;
  acc_ = acc;
  if (acc) {
    set_has_acc();
  } else {
    clear_has_acc();
  }
}

// repeated .Star.TaskInfo task = 2;
inline int UploadTaskInfoReq::task_size() const {
  return task_.size();
}
inline void UploadTaskInfoReq::clear_task() {
  task_.Clear();
}
inline const ::Star::TaskInfo& UploadTaskInfoReq::task(int index) const {
  return task_.Get(index);
}
inline ::Star::TaskInfo* UploadTaskInfoReq::mutable_task(int index) {
  return task_.Mutable(index);
}
inline ::Star::TaskInfo* UploadTaskInfoReq::add_task() {
  return task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
UploadTaskInfoReq::task() const {
  return task_;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
UploadTaskInfoReq::mutable_task() {
  return &task_;
}

// -------------------------------------------------------------------

// UploadTaskInfoRsp

// required int32 rsp_code = 1;
inline bool UploadTaskInfoRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadTaskInfoRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadTaskInfoRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadTaskInfoRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 UploadTaskInfoRsp::rsp_code() const {
  return rsp_code_;
}
inline void UploadTaskInfoRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// -------------------------------------------------------------------

// UploadSolutionReq

// required .Star.AccountInfo acc = 1;
inline bool UploadSolutionReq::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadSolutionReq::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadSolutionReq::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadSolutionReq::clear_acc() {
  if (acc_ != NULL) acc_->::Star::AccountInfo::Clear();
  clear_has_acc();
}
inline const ::Star::AccountInfo& UploadSolutionReq::acc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return acc_ != NULL ? *acc_ : *default_instance().acc_;
#else
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
#endif
}
inline ::Star::AccountInfo* UploadSolutionReq::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::Star::AccountInfo;
  return acc_;
}
inline ::Star::AccountInfo* UploadSolutionReq::release_acc() {
  clear_has_acc();
  ::Star::AccountInfo* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline void UploadSolutionReq::set_allocated_acc(::Star::AccountInfo* acc) {
  delete acc_;
  acc_ = acc;
  if (acc) {
    set_has_acc();
  } else {
    clear_has_acc();
  }
}

// repeated .Star.SolutionInfo solution = 2;
inline int UploadSolutionReq::solution_size() const {
  return solution_.size();
}
inline void UploadSolutionReq::clear_solution() {
  solution_.Clear();
}
inline const ::Star::SolutionInfo& UploadSolutionReq::solution(int index) const {
  return solution_.Get(index);
}
inline ::Star::SolutionInfo* UploadSolutionReq::mutable_solution(int index) {
  return solution_.Mutable(index);
}
inline ::Star::SolutionInfo* UploadSolutionReq::add_solution() {
  return solution_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >&
UploadSolutionReq::solution() const {
  return solution_;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >*
UploadSolutionReq::mutable_solution() {
  return &solution_;
}

// -------------------------------------------------------------------

// UploadSolutionRsp

// required int32 rsp_code = 1;
inline bool UploadSolutionRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadSolutionRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadSolutionRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadSolutionRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 UploadSolutionRsp::rsp_code() const {
  return rsp_code_;
}
inline void UploadSolutionRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// -------------------------------------------------------------------

// DownloadSolutionReq

// required .Star.AccountInfo acc = 1;
inline bool DownloadSolutionReq::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadSolutionReq::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadSolutionReq::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadSolutionReq::clear_acc() {
  if (acc_ != NULL) acc_->::Star::AccountInfo::Clear();
  clear_has_acc();
}
inline const ::Star::AccountInfo& DownloadSolutionReq::acc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return acc_ != NULL ? *acc_ : *default_instance().acc_;
#else
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
#endif
}
inline ::Star::AccountInfo* DownloadSolutionReq::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::Star::AccountInfo;
  return acc_;
}
inline ::Star::AccountInfo* DownloadSolutionReq::release_acc() {
  clear_has_acc();
  ::Star::AccountInfo* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline void DownloadSolutionReq::set_allocated_acc(::Star::AccountInfo* acc) {
  delete acc_;
  acc_ = acc;
  if (acc) {
    set_has_acc();
  } else {
    clear_has_acc();
  }
}

// optional string solution_id = 2;
inline bool DownloadSolutionReq::has_solution_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownloadSolutionReq::set_has_solution_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownloadSolutionReq::clear_has_solution_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownloadSolutionReq::clear_solution_id() {
  if (solution_id_ != &::google::protobuf::internal::kEmptyString) {
    solution_id_->clear();
  }
  clear_has_solution_id();
}
inline const ::std::string& DownloadSolutionReq::solution_id() const {
  return *solution_id_;
}
inline void DownloadSolutionReq::set_solution_id(const ::std::string& value) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(value);
}
inline void DownloadSolutionReq::set_solution_id(const char* value) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(value);
}
inline void DownloadSolutionReq::set_solution_id(const char* value, size_t size) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadSolutionReq::mutable_solution_id() {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  return solution_id_;
}
inline ::std::string* DownloadSolutionReq::release_solution_id() {
  clear_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = solution_id_;
    solution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DownloadSolutionReq::set_allocated_solution_id(::std::string* solution_id) {
  if (solution_id_ != &::google::protobuf::internal::kEmptyString) {
    delete solution_id_;
  }
  if (solution_id) {
    set_has_solution_id();
    solution_id_ = solution_id;
  } else {
    clear_has_solution_id();
    solution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DownloadSolutionRsp

// required int32 rsp_code = 1;
inline bool DownloadSolutionRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadSolutionRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadSolutionRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadSolutionRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 DownloadSolutionRsp::rsp_code() const {
  return rsp_code_;
}
inline void DownloadSolutionRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// optional .Star.SolutionInfo soulution = 2;
inline bool DownloadSolutionRsp::has_soulution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownloadSolutionRsp::set_has_soulution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownloadSolutionRsp::clear_has_soulution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownloadSolutionRsp::clear_soulution() {
  if (soulution_ != NULL) soulution_->::Star::SolutionInfo::Clear();
  clear_has_soulution();
}
inline const ::Star::SolutionInfo& DownloadSolutionRsp::soulution() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return soulution_ != NULL ? *soulution_ : *default_instance().soulution_;
#else
  return soulution_ != NULL ? *soulution_ : *default_instance_->soulution_;
#endif
}
inline ::Star::SolutionInfo* DownloadSolutionRsp::mutable_soulution() {
  set_has_soulution();
  if (soulution_ == NULL) soulution_ = new ::Star::SolutionInfo;
  return soulution_;
}
inline ::Star::SolutionInfo* DownloadSolutionRsp::release_soulution() {
  clear_has_soulution();
  ::Star::SolutionInfo* temp = soulution_;
  soulution_ = NULL;
  return temp;
}
inline void DownloadSolutionRsp::set_allocated_soulution(::Star::SolutionInfo* soulution) {
  delete soulution_;
  soulution_ = soulution;
  if (soulution) {
    set_has_soulution();
  } else {
    clear_has_soulution();
  }
}

// -------------------------------------------------------------------

// UpSolutionReq

// required .Star.AccountInfo acc = 1;
inline bool UpSolutionReq::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpSolutionReq::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpSolutionReq::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpSolutionReq::clear_acc() {
  if (acc_ != NULL) acc_->::Star::AccountInfo::Clear();
  clear_has_acc();
}
inline const ::Star::AccountInfo& UpSolutionReq::acc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return acc_ != NULL ? *acc_ : *default_instance().acc_;
#else
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
#endif
}
inline ::Star::AccountInfo* UpSolutionReq::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::Star::AccountInfo;
  return acc_;
}
inline ::Star::AccountInfo* UpSolutionReq::release_acc() {
  clear_has_acc();
  ::Star::AccountInfo* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline void UpSolutionReq::set_allocated_acc(::Star::AccountInfo* acc) {
  delete acc_;
  acc_ = acc;
  if (acc) {
    set_has_acc();
  } else {
    clear_has_acc();
  }
}

// optional string solution_id = 2;
inline bool UpSolutionReq::has_solution_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpSolutionReq::set_has_solution_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpSolutionReq::clear_has_solution_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpSolutionReq::clear_solution_id() {
  if (solution_id_ != &::google::protobuf::internal::kEmptyString) {
    solution_id_->clear();
  }
  clear_has_solution_id();
}
inline const ::std::string& UpSolutionReq::solution_id() const {
  return *solution_id_;
}
inline void UpSolutionReq::set_solution_id(const ::std::string& value) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(value);
}
inline void UpSolutionReq::set_solution_id(const char* value) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(value);
}
inline void UpSolutionReq::set_solution_id(const char* value, size_t size) {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  solution_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpSolutionReq::mutable_solution_id() {
  set_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    solution_id_ = new ::std::string;
  }
  return solution_id_;
}
inline ::std::string* UpSolutionReq::release_solution_id() {
  clear_has_solution_id();
  if (solution_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = solution_id_;
    solution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpSolutionReq::set_allocated_solution_id(::std::string* solution_id) {
  if (solution_id_ != &::google::protobuf::internal::kEmptyString) {
    delete solution_id_;
  }
  if (solution_id) {
    set_has_solution_id();
    solution_id_ = solution_id;
  } else {
    clear_has_solution_id();
    solution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_up = 3;
inline bool UpSolutionReq::has_is_up() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpSolutionReq::set_has_is_up() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpSolutionReq::clear_has_is_up() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpSolutionReq::clear_is_up() {
  is_up_ = false;
  clear_has_is_up();
}
inline bool UpSolutionReq::is_up() const {
  return is_up_;
}
inline void UpSolutionReq::set_is_up(bool value) {
  set_has_is_up();
  is_up_ = value;
}

// -------------------------------------------------------------------

// UpSolutionRsp

// required int32 rsp_code = 1;
inline bool UpSolutionRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpSolutionRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpSolutionRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpSolutionRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 UpSolutionRsp::rsp_code() const {
  return rsp_code_;
}
inline void UpSolutionRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// optional .Star.SolutionInfo soulution = 2;
inline bool UpSolutionRsp::has_soulution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpSolutionRsp::set_has_soulution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpSolutionRsp::clear_has_soulution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpSolutionRsp::clear_soulution() {
  if (soulution_ != NULL) soulution_->::Star::SolutionInfo::Clear();
  clear_has_soulution();
}
inline const ::Star::SolutionInfo& UpSolutionRsp::soulution() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return soulution_ != NULL ? *soulution_ : *default_instance().soulution_;
#else
  return soulution_ != NULL ? *soulution_ : *default_instance_->soulution_;
#endif
}
inline ::Star::SolutionInfo* UpSolutionRsp::mutable_soulution() {
  set_has_soulution();
  if (soulution_ == NULL) soulution_ = new ::Star::SolutionInfo;
  return soulution_;
}
inline ::Star::SolutionInfo* UpSolutionRsp::release_soulution() {
  clear_has_soulution();
  ::Star::SolutionInfo* temp = soulution_;
  soulution_ = NULL;
  return temp;
}
inline void UpSolutionRsp::set_allocated_soulution(::Star::SolutionInfo* soulution) {
  delete soulution_;
  soulution_ = soulution;
  if (soulution) {
    set_has_soulution();
  } else {
    clear_has_soulution();
  }
}

// -------------------------------------------------------------------

// FriendsInfo

// required string account = 1;
inline bool FriendsInfo::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendsInfo::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendsInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendsInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& FriendsInfo::account() const {
  return *account_;
}
inline void FriendsInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void FriendsInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void FriendsInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendsInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* FriendsInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendsInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Star.SolutionInfo solution = 2;
inline int FriendsInfo::solution_size() const {
  return solution_.size();
}
inline void FriendsInfo::clear_solution() {
  solution_.Clear();
}
inline const ::Star::SolutionInfo& FriendsInfo::solution(int index) const {
  return solution_.Get(index);
}
inline ::Star::SolutionInfo* FriendsInfo::mutable_solution(int index) {
  return solution_.Mutable(index);
}
inline ::Star::SolutionInfo* FriendsInfo::add_solution() {
  return solution_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >&
FriendsInfo::solution() const {
  return solution_;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::SolutionInfo >*
FriendsInfo::mutable_solution() {
  return &solution_;
}

// -------------------------------------------------------------------

// QueryFriendsInfoReq

// required .Star.PlatformType platform = 1;
inline bool QueryFriendsInfoReq::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryFriendsInfoReq::set_has_platform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryFriendsInfoReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryFriendsInfoReq::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::Star::PlatformType QueryFriendsInfoReq::platform() const {
  return static_cast< ::Star::PlatformType >(platform_);
}
inline void QueryFriendsInfoReq::set_platform(::Star::PlatformType value) {
  assert(::Star::PlatformType_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// repeated string account_list = 2;
inline int QueryFriendsInfoReq::account_list_size() const {
  return account_list_.size();
}
inline void QueryFriendsInfoReq::clear_account_list() {
  account_list_.Clear();
}
inline const ::std::string& QueryFriendsInfoReq::account_list(int index) const {
  return account_list_.Get(index);
}
inline ::std::string* QueryFriendsInfoReq::mutable_account_list(int index) {
  return account_list_.Mutable(index);
}
inline void QueryFriendsInfoReq::set_account_list(int index, const ::std::string& value) {
  account_list_.Mutable(index)->assign(value);
}
inline void QueryFriendsInfoReq::set_account_list(int index, const char* value) {
  account_list_.Mutable(index)->assign(value);
}
inline void QueryFriendsInfoReq::set_account_list(int index, const char* value, size_t size) {
  account_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryFriendsInfoReq::add_account_list() {
  return account_list_.Add();
}
inline void QueryFriendsInfoReq::add_account_list(const ::std::string& value) {
  account_list_.Add()->assign(value);
}
inline void QueryFriendsInfoReq::add_account_list(const char* value) {
  account_list_.Add()->assign(value);
}
inline void QueryFriendsInfoReq::add_account_list(const char* value, size_t size) {
  account_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryFriendsInfoReq::account_list() const {
  return account_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryFriendsInfoReq::mutable_account_list() {
  return &account_list_;
}

// repeated int64 task_list = 3;
inline int QueryFriendsInfoReq::task_list_size() const {
  return task_list_.size();
}
inline void QueryFriendsInfoReq::clear_task_list() {
  task_list_.Clear();
}
inline ::google::protobuf::int64 QueryFriendsInfoReq::task_list(int index) const {
  return task_list_.Get(index);
}
inline void QueryFriendsInfoReq::set_task_list(int index, ::google::protobuf::int64 value) {
  task_list_.Set(index, value);
}
inline void QueryFriendsInfoReq::add_task_list(::google::protobuf::int64 value) {
  task_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
QueryFriendsInfoReq::task_list() const {
  return task_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
QueryFriendsInfoReq::mutable_task_list() {
  return &task_list_;
}

// -------------------------------------------------------------------

// QueryFriendsInfoRsp

// required int32 rsp_code = 1;
inline bool QueryFriendsInfoRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryFriendsInfoRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryFriendsInfoRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryFriendsInfoRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 QueryFriendsInfoRsp::rsp_code() const {
  return rsp_code_;
}
inline void QueryFriendsInfoRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .Star.TaskInfo task = 2;
inline int QueryFriendsInfoRsp::task_size() const {
  return task_.size();
}
inline void QueryFriendsInfoRsp::clear_task() {
  task_.Clear();
}
inline const ::Star::TaskInfo& QueryFriendsInfoRsp::task(int index) const {
  return task_.Get(index);
}
inline ::Star::TaskInfo* QueryFriendsInfoRsp::mutable_task(int index) {
  return task_.Mutable(index);
}
inline ::Star::TaskInfo* QueryFriendsInfoRsp::add_task() {
  return task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >&
QueryFriendsInfoRsp::task() const {
  return task_;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::TaskInfo >*
QueryFriendsInfoRsp::mutable_task() {
  return &task_;
}

// repeated .Star.FriendsInfo friend = 3;
inline int QueryFriendsInfoRsp::friend__size() const {
  return friend__.size();
}
inline void QueryFriendsInfoRsp::clear_friend_() {
  friend__.Clear();
}
inline const ::Star::FriendsInfo& QueryFriendsInfoRsp::friend_(int index) const {
  return friend__.Get(index);
}
inline ::Star::FriendsInfo* QueryFriendsInfoRsp::mutable_friend_(int index) {
  return friend__.Mutable(index);
}
inline ::Star::FriendsInfo* QueryFriendsInfoRsp::add_friend_() {
  return friend__.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Star::FriendsInfo >&
QueryFriendsInfoRsp::friend_() const {
  return friend__;
}
inline ::google::protobuf::RepeatedPtrField< ::Star::FriendsInfo >*
QueryFriendsInfoRsp::mutable_friend_() {
  return &friend__;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Star

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protomsg_2eproto__INCLUDED
